### Dinic

```cpp
int n, m, s, t, cnt = 1, to[N], from[N], Next[N], d[N], val[N];
int ans;
queue<int>q;
inline void add(int x, int y, int z)
{
	to[++cnt] = y;
	Next[cnt] = from[x];
	from[x] = cnt;
	val[cnt] = z;
}
int bfs()
{
	memset(d, 0, sizeof(d));
	d[s] = 1;
	while (q.size())q.pop();
	q.push(s);
	while (q.size())
	{
		int x = q.front();
		q.pop();
		for (int i = from[x]; i; i = Next[i])
		{
			int y = to[i];
			if (val[i] && !d[y])
			{
				d[y] = d[x] + 1;
				if (y == t)return 1;
				q.push(y);
			}
		}
	}
	return 0;
}
int dinic(int x, int flow)
{
	if (x == t)return flow;
	int k, rest = flow;
	for (int i = from[x]; i; i = Next[i])
	{
		int y = to[i];
		if (val[i] && d[y] == d[x] + 1)
		{
			k = dinic(y, min(rest, val[i]));
			if (!k)d[y] = 0;
			rest -= k;
			val[i] -= k;
			val[i ^ 1] += k;
		}
	}
	return flow - rest;
}
int main()
{
	n = read(), m = read();
	s = 0, t = n + 1;
	for (int i = 1; i <= n; i++)
	{
		int x = read();
		if (x)
		{
			add(s, i, 1);
			add(i, s, 0);
		}
		else
		{
			add(i, t, 1);
			add(t, i, 0);
		}
	}
	while (m--)
	{
		int x = read(), y = read();
		add(x, y, 1);
		add(y, x, 0);
		add(y, x, 1);
		add(x, y, 0);
	}
	while (bfs())
		ans += dinic(0, INF);
	printf("%d\n", ans);
	return 0;
}
```

### Kmp

```cpp
void KMP()
{
    Next[0] = -1;
    int k = -1;
    for (int q = 1; q < len2; q++)
    {
        while (k != -1 && st2[k + 1] != st2[q])
            k = Next[k];
        if (st2[k + 1] == st2[q])
            k++;
        Next[q] = k;
    }
    k = -1;
    for (int i = 0; i < len1; i++)
    {
        while (k != -1 && st2[k + 1] != st1[i])
            k = Next[k];
        if (st2[k + 1] == st1[i]) k++;
        if (k == len2 - 1)
        {
            i = i - len2 + 1;
            k = -1;
            cout << i + 1 << endl;
        }
    }
}
int main()
{
    cin >> st1;
    cin >> st2;
    len1 = st1.length();
    len2 = st2.length();
    KMP();
    for (int i = 0; i < len2; i++)
        cout << Next[i] + 1 << " ";
    return 0;
}
```

### Lucas、组合数、快速幂

```cpp
int qpow(int x, int k)
{
	int tep = 1;
	while (k)
	{
		if (k & 1)
			tep = (tep * x) % p;
		x = (x * x) % p;
		k >>= 1;
	}
	return tep;
}
int C(int x, int y)
{
	if (x < y)
		return 0;
	return (jc[x] * qpow(jc[x - y], p - 2) % p * qpow(jc[y], p - 2));

}
int lucas(int x, int y)
{
	if (!y)
		return 1;
	return C(x % p, y % p) * lucas(x / p, y / p) % p;
}
void init()
{
	memset(jc, 0, sizeof(jc));
	jc[0] = 1;
	for (int i = 1; i <= p; i++)
		jc[i] = (jc[i - 1] * i) % p;
}
signed main()
{
	int T = read();
	while (T--)
	{
		int n = read(), m = read();
		p = read();
		init();
		printf("%lld\n", lucas(n + m, n));
	}
	return 0;
}
```

### SPFA最小费用最大流

```cpp
int n, m, s, t, cnt = 1;
inline void add(int x, int y, int z, int Cost)
{
	to[++cnt] = y;
	Next[cnt] = from[x];
	from[x] = cnt;
	val[cnt] = z;
	fy[cnt] = Cost;
}
int spfa()
{
	memset(vis, 0, sizeof(vis));
	memset(cost, 0x7f, sizeof(cost));
	memset(flow, 0x7f, sizeof(flow));
	pre[t] = -1;
	q.push(s);
	vis[s] = 1;
	cost[s] = 0;
	while (q.size())
	{
		int x = q.front();
		q.pop();
		vis[x] = 0;
		for (int i = from[x]; i; i = Next[i])
		{
			int y = to[i];
			if (val[i] && cost[x] + fy[i] < cost[y])
			{
				cost[y] = cost[x] + fy[i];
				pre[y] = x;
				last[y] = i;
				flow[y] = min(flow[x], val[i]);
				if (!vis[y])
				{
					vis[y] = 1;
					q.push(y);
				}
			}
		}
	}
	return pre[t] != -1;
}
int main()
{
	n = read(), m = read(), s = read(), t = read();
	while (m--)
	{
		int x = read(), y = read(), z = read(), Cost = read();
		add(x, y, z, Cost);
		add(y, x, 0, -Cost);
	}
	while (spfa())
	{
		int x = t;
		ans_flow += flow[t];
		ans_cost += flow[t] * cost[t];
		while (x != s)
		{
			val[last[x]] -= flow[t];
			val[last[x] ^ 1] += flow[t];
			x = pre[x];
		}
	}
	printf("%lld %lld\n", ans_flow, ans_cost);
	return 0;
}
```

### st表

```cpp
signed main()
{
    int n = read();
    for (int i = 1; i <= n; i++)
        st[i][0] = read();
    for (int j = 1; j <= 20; j++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++)
            st[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
    int m = read();
    while (m--)
    {
        int x = read(), y = read();
        int k = log(y - x + 1) / log(2);
        printf("%lld\n", max(st[x][k], st[y - (1 << k) + 1][k]));
    }
    return 0;
}
```

### tarjan缩点

```cpp
void tarjan(int x)
{
	in[x] = 1;
	s.push(x);
	dfn[x] = low[x] = ++cnt;
	for (int i = from[x]; i; i = Next[i])
	{
		int y = to[i];
		if (!dfn[y])
		{
			tarjan(y);
			low[x] = min(low[x], low[y]);
		}
		else if (in[y])
			low[x] = min(low[x], dfn[y]);
	}
	if (dfn[x] == low[x])
	{
		M++;
		while (s.top() != x)
		{
			int X = s.top();
			s.pop();
			id[X] = M;
			in[X] = 0;
			sum[M] += w[X];
		}
		int X = s.top();
		s.pop();
		id[X] = M;
		in[X] = 0;
		sum[M] += w[X];
	}
}
int main()
{
	n = read(), m = read();
	for (int i = 1; i <= n; i++)
		w[i] = read();

	for (int i = 1; i <= m; i++)
	{
		e[i].from = read();
		e[i].to = read();
		add(e[i].from, e[i].to);
	}
	cnt = 0;
	for (int i = 1; i <= n; i++)
		if (!dfn[i])
			tarjan(i);
```

### Trie

```cpp
struct Node {
	int son[27], ed, vis;
} trie[N];
void insert(string str)
{
	int pos = 1;
	int len = str.size();
	for (int i = 0; i < len; i++)
	{
		int x = str[i] - 'a';
		if (!trie[pos].son[x])
			trie[pos].son[x] = ++tot;
		pos = trie[pos].son[x];
	}
	trie[pos].ed = 1;
}
void work(string str)
{
	int pos = 1;
	int len = str.size();
	for (int i = 0; i < len; i++)
	{
		int x = str[i] - 'a';
		if (!trie[pos].son[x])
		{
			printf("WRONG\n");
			return;
		}
		pos = trie[pos].son[x];
	}
	if (!trie[pos].ed)
	{
		printf("WRONG\n");
		return;
	}
	else if (trie[pos].vis)
	{
		printf("REPEAT\n");
		return;
	}
	else
	{
		printf("OK\n");
		trie[pos].vis = 1;
	}
}
int main()
{
	int n = read();
	for (int i = 1; i <= n; i++)
	{
		string st;
		cin >> st;
		insert(st);
	}
	int m = read();
	while (m--)
	{
		string st;
		cin >> st;
		work(st);
	}
	return 0;
}
```

### 倍增LCA

```cpp
void dfs(int x, int father)
{
	dep[x] = dep[father] + 1;
	fa[x][0] = father;
	for (int i = 1; (1 << i) <= dep[x]; i++)
		fa[x][i] = fa[fa[x][i - 1]][i - 1];
	for (auto y : a[x])
		if (y != father)dfs(y, x);
}
int LCA(int x, int y)
{
	if (dep[x] < dep[y])swap(x, y);
	for (int i = 20; i >= 0; i--)
		if (dep[fa[x][i]] >= dep[y])x = fa[x][i];
	if (x == y)
		return x;
	for (int i = 20; i >= 0; i--)
		if (fa[x][i] != fa[y][i])
		{
			x = fa[x][i];
			y = fa[y][i];
		}
	return fa[x][0];
}
```

### 并查集

```cpp
int find(int x)
{
	if (fa[x] != x)fa[x] = find(fa[x]);
	return fa[x];
}
int main()
{
	int n = read(), m = read();
	for (int i = 1; i <= n; i++)
		fa[i] = i;
	while (m--)
	{
		int opt = read(), x = read(), y = read();
		if (opt == 1)
			fa[find(x)] = fa[find(y)];
		else
		{
			if (find(x) == find(y))
				printf("Y\n");
			else
				printf("N\n");
		}
	}
	return 0;
}	
```

### 堆优化DIJ

```cpp
	memset(d, 0x3f, sizeof(d));
	d[s] = 0;
	priority_queue<pair<int, int > >q;
	q.push(make_pair(0, s));
	while (!q.empty())
	{
		int val = -q.top().first;
		int x = q.top().second;
		q.pop();
		if (vis[x] || val > d[x])continue;
		vis[x] = 1;
		for (int i = 0; i < a[x].size(); i++)
		{
			int y = a[x][i];
			if (val + v[x][i] < d[y])
			{
				d[y] = val + v[x][i];
				q.push(make_pair(-d[y], y));
			}
		}
	}
	for (int i = 1; i <= n; i++)
		printf("%d ", d[i]);
```

### 分块

```cpp
signed main()
{
    int n = read(), m = read();
    int len = sqrt(n);
    int tot = (n + len - 1) / len;
    for (int i = 1; i <= n; i++)
    {
        a[i] = read();
        id[i] = (i - 1) / len + 1;
        sum[id[i]] += a[i];
    }
    for (int i = 1; i <= tot; i++)
    {
        L[i] = (i - 1) * len + 1;
        R[i] = i * len;
    }
    while (m--)
    {
        int p = read();
        if (p == 1)
        {
            int x = read(), y = read(), z = read();
            if (id[x] == id[y])
                for (int i = x; i <= y; i++)
                    a[i] += z, sum[id[i]] += z;
            else
            {
                for (int i = x; i <= R[id[x]]; i++)
                    a[i] += z, sum[id[i]] += z;
                for (int i = L[id[y]]; i <= y; i++)
                    a[i] += z, sum[id[i]] += z;
                for (int i = id[x] + 1; i <= id[y] - 1; i++)
                    lazy[i] += z;
            }
        }
        else
        {
            int x = read(), y = read();
            int s = 0;
            if (id[x] == id[y])
                for (int i = x; i <= y; i++)
                    s += a[i] + lazy[id[i]];
            else
            {
                for (int i = x; i <= R[id[x]]; i++)
                    s += a[i] + lazy[id[i]];
                for (int i = L[id[y]]; i <= y; i++)
                    s += a[i] + lazy[id[i]];
                for (int i = id[x] + 1; i <= id[y] - 1; i++)
                    s += sum[i] + lazy[i] * len;
            }
            printf("%lld\n", s);
        }
    }
    return 0;
}
```

### 矩阵快速幂

```cpp
struct mat
{
	int M[N][N];
} ori, ans;
mat mul(mat a, mat b, int n)
{
	mat tep;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
		{
			tem.M[i][j] = 0;
			for (int k = 1; k <= n; k++)
				tep.M[i][j] = (tep.M[i][j] + (a.M[i][k] * b.M[k][j]) % P) % P;
		}
	return tep;
}
void qpow_mat(int n, int k)
{
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			ans.M[i][j] = (i == j);
	while (k)
	{
		if (k & 1)
			ans = mul(ans, ori, n);
		ori = mul(ori, ori, n);
		k >>= 1;
	}
}
signed main()
{
	int n = read(), k = read();
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			ori.M[i][j] = read();
	qpow_mat(n, k);
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
			printf("%lld ", ans.M[i][j]);
		printf("\n");
	}
	return 0;
}
```

### 模拟退火

```cpp
void SA()
{
    double t = 3000;
    while (t >= 1e-15)
    {
        double x1 = ansx + (rand() * 2 - RAND_MAX) * t;
        double y1 = ansy + (rand() * 2 - RAND_MAX) * t;
        double z1 = ansz + (rand() * 2 - RAND_MAX) * t;
        double ans1 = cal(x1, y1, z1);
        double d = ans1 - ans;
        if (d < 0)
        {
            ansx = x1;
            ansy = y1;
            ansz = z1;
            ans = ans1;
        }
        else if (exp(-d / t) * RAND_MAX > rand())
        {
            ansx = x1;
            ansy = y1;
            ansz = z1;
        }
        t *= down;
    }
}
```

### 莫队

```cpp
inline int cmp(Node x, Node y)
{
    if (x.pos != y.pos)return x.pos < y.pos;
    if (x.pos % 2)return x.r < y.r;
    else return x.r > y.r;
}
void add(int pos)
{
    ans_tep += 2 * cnt[a[pos]] + 1;
    cnt[a[pos]]++;
}
void remove(int pos)
{
    ans_tep += 1 - cnt[a[pos]] * 2;
    cnt[a[pos]]--;
}
int main()
{
    n = read(), m = read(), k = read();
    len = (int)sqrt(n);
    for (int i = 1; i <= n; i++)
        a[i] = read();
    for (int i = 1; i <= m; i++)
    {
        ask[i].l = read(), ask[i].r = read();
        ask[i].id = i;
        ask[i].pos = (ask[i].l - 1) / len + 1;
    }
    sort(ask + 1, ask + m + 1, cmp);
    int L = 0, R = 0;
    for (int i = 1; i <= m; i++)
    {
        while (L < ask[i].l)remove(L++);
        while (L > ask[i].l)add(--L);
        while (R > ask[i].r)remove(R--);
        while (R < ask[i].r)add(++R);
        ans[ask[i].id] = ans_tep;
    }
    for (int i = 1; i <= m; i++)
        printf("%lld\n", ans[i] - 1);
    return 0;
}
```

### 树状数组逆序对

```cpp
int low(int x)
{
	return x & -x;
}
void add(int x)
{
	for (; x <= cnt; x += low(x))
		tree[x]++;
}
int sum(int x)
{
	int s = 0;
	for (; x != 0; x -= low(x))
		s += tree[x];
	return s;
}
signed main()
{
	int n = read();
	vector<int>v;
	for (int i = 1; i <= n; i++)
	{
		a[i] = read();
		v.push_back(a[i]);
	}
	sort(v.begin(), v.end());
	map<int, int>M;
	for (auto x : v)
		if (M.find(x) == M.end())
			M[x] = ++cnt;
	int ans = 0;
	for (int i = 1; i <= n; i++)
	{
		add(M[a[i]]);
		ans += i - sum(M[a[i]]);
	}
	printf("%lld\n", ans);
	return 0;
}
```

### fhq_treap

```cpp
using namespace std;
int n, cnt, root;
struct Node {
	int v, rnd, son[2], size;
} tree[MAXN];

void PushUp(int k)
{
	tree[k].size = tree[tree[k].son[0]].size + tree[tree[k].son[1]].size + 1;
}
int build(int v)
{
	++cnt;
	tree[cnt].size = 1;
	tree[cnt].v = v;
	tree[cnt].rnd = rand();
	return cnt;
}
int merge(int x, int y)
{
	if (!x || !y)return x + y;
	if (tree[x].rnd < tree[y].rnd)
	{
		tree[x].son[1] = merge(tree[x].son[1], y);
		PushUp(x);
		return x;
	}
	else
	{
		tree[y].son[0] = merge(x, tree[y].son[0]);
		PushUp(y);
		return y;
	}
}
void split(int now, int k, int &x, int &y)
{
	if (!now)x = y = 0;
	else
	{
		if (tree[now].v <= k)
		{
			x = now;
			split(tree[now].son[1], k, tree[now].son[1], y);
		}
		else
		{
			y = now;
			split(tree[now].son[0], k, x, tree[now].son[0]);
		}
		PushUp(now);
	}
}
int kth(int now, int k)
{
	while (1)
	{
		if (k <= tree[tree[now].son[0]].size)
			now = tree[now].son[0];
		else
		{
			if (k == tree[tree[now].son[0]].size + 1)
				return now;
			else
			{
				k -= tree[tree[now].son[0]].size + 1;
				now = tree[now].son[1];
			}
		}
	}
}
int main()
{
	srand(time(NULL));
	n = read();
	int x, y, z;
	while (n--)
	{
		int opt = read(), a = read();
		if (opt == 1)
		{
			split(root, a, x, y);
			root = merge(merge(x, build(a)), y);
		}//插入x
		if (opt == 2)
		{
			split(root, a, x, z);
			split(x, a - 1, x, y);
			y = merge(tree[y].son[0], tree[y].son[1]);
			root = merge(merge(x, y), z);
		}//删除x
		if (opt == 3)
		{
			split(root, a - 1, x, y);
			printf("%d\n", tree[x].size + 1);
			root = merge(x, y);
		}//查询x的排名
		if (opt == 4)
			printf("%d\n", tree[kth(root, a)].v);//查询排名为x的数
		if (opt == 5)
		{
			split(root, a - 1, x, y);
			printf("%d\n", tree[kth(x, tree[x].size)].v);
			root = merge(x, y);
		}//求x前驱
		if (opt == 6)
		{
			split(root, a, x, y);
			printf("%d\n", tree[kth(y, 1)].v);
			root = merge(x, y);
		}//求x后缀
	}
	return 0;
}
```

### 树链剖分

```cpp
void PushUp(int k)
{
	tree[k].w = tree[k << 1].w + tree[k << 1 | 1].w;
	tree[k].w %= P;
}
void PushDown(int k)
{
	if (tree[k].f)
	{
		int x = tree[k].f;
		tree[k].f = 0;
		tree[k << 1].f += x;
		tree[k << 1 | 1].f += x;
		tree[k << 1].w += x * (tree[k << 1].r - tree[k << 1].l + 1);
		tree[k << 1 | 1].w += x * (tree[k << 1 | 1].r - tree[k << 1 | 1].l + 1);
		tree[k << 1].w %= P;
		tree[k << 1 | 1].w %= P;
	}
}
void build(int k, int ll, int rr)
{
	tree[k].l = ll;
	tree[k].r = rr;
	if (ll == rr)
	{
		tree[k].w = a[ll];
		return;
	}
	int mid = (ll + rr) >> 1;
	build(k << 1, ll, mid);
	build(k << 1 | 1, mid + 1, rr);
	PushUp(k);
}
void change(int k, int ll, int rr, int d)
{
	if (tree[k].l >= ll && tree[k].r <= rr)
	{
		tree[k].f += d;
		tree[k].w += d * (tree[k].r - tree[k].l + 1);
		return;
	}
	PushDown(k);
	int mid = (tree[k].l + tree[k].r) >> 1;
	if (mid >= ll)change(k << 1, ll, rr, d);
	if (rr > mid)change(k << 1 | 1, ll, rr, d);
	PushUp(k);
}
int search(int k, int ll, int rr)
{
	int ans = 0;
	if (tree[k].l >= ll && tree[k].r <= rr)
		return tree[k].w % P;
	PushDown(k);
	int mid = (tree[k].l + tree[k].r) >> 1;
	if (mid >= ll)ans += search(k << 1, ll, rr);
	if (rr > mid)ans += search(k << 1 | 1, ll, rr);
	return ans % P;
}
int dfs1(int x, int f, int dep)
{
	deep[x] = dep;
	fa[x] = f;
	size[x] = 1;
	int maxson = -1;
	for (int i = 0; i < v[x].size(); i++)
	{
		int y = v[x][i];
		if (y == fa[x])continue;
		size[x] += dfs1(y, x, dep + 1);
		if (size[y] > maxson)
		{
			son[x] = y;
			maxson = size[y];
		}
	}
	return size[x];
}
void dfs2(int x, int topf)
{
	top[x] = topf;
	id[x] = ++cnt;
	a[cnt] = b[x];
	if (!son[x])return;
	dfs2(son[x], topf);
	for (int i = 0; i < v[x].size(); i++)
		if (!id[v[x][i]])
			dfs2(v[x][i], v[x][i]);
}
void path_change(int x, int y, int z)
{
	while (top[x] != top[y])
	{
		if (deep[top[x]] < deep[top[y]])swap(x, y);
		change(1, id[top[x]], id[x], z);
		x = fa[top[x]];
	}
	if (deep[x] > deep[y])swap(x, y);
	change(1, id[x], id[y], z);
}
void path_search(int x, int y)
{
	int ans = 0;
	while (top[x] != top[y])
	{
		if (deep[top[x]] < deep[top[y]])swap(x, y);
		ans += search(1, id[top[x]], id[x]);
		ans %= P;
		x = fa[top[x]];
	}
	if (deep[x] > deep[y])swap(x, y);
	ans += search(1, id[x], id[y]);
	cout << ans % P << endl;
}
void tree_change(int x, int y)
{
	change(1, id[x], id[x] + size[x] - 1, y);
}
void tree_search(int x)
{
	cout << search(1, id[x], id[x] + size[x] - 1) << endl;
}
int main()
{
	n = read(), m = read(), r = read(), P = read();
	for (int i = 1; i <= n; i++)
		b[i] = read();
	for (int i = 1; i < n; i++)
	{
		int x = read(), y = read();
		v[x].push_back(y);
		v[y].push_back(x);
	}
	dfs1(r, 0, 1);
	dfs2(r, r);
	build(1, 1, n);
	for (int i = 1; i <= m; i++)
	{
		int p = read();
		if (p == 1)
		{
			int x = read(), y = read(), z = read();
			path_change(x, y, z);
		}
		if (p == 2)
		{
			int x = read(), y = read();
			path_search(x, y);
		}
		if (p == 3)
		{
			int x = read(), y = read();
			tree_change(x, y);
		}
		if (p == 4)
		{
			int x = read();
			tree_search(x);
		}
	}
	return 0;
}
```

### 线性乘法逆元

```cpp
int main()
{
	int n = read(), p = read();
	inv[1] = 1;
	printf("1\n");
	for (register int i = 2; i <= n; i++)
	{
		inv[i] = (LL)(p - p / i) * inv[p % i] % p;
		printf("%d\n", inv[i]);
	}
	return 0;
}
```

### 主席树

```cpp
//静态区间第k小
#include<bits/stdc++.h>
#define LL long long
#define maxn 200005
using namespace std;
int n, m, q, cnt;
int L[maxn << 5], R[maxn << 5], sum[maxn << 5], T[maxn], a[maxn], b[maxn];
inline int build(int l, int r)
{
    int rt = ++cnt;
    sum[rt] = 0;
    if (l < r)
    {
        int mid = (l + r) >> 1;
        L[rt] = build(l, mid);
        R[rt] = build(mid + 1, r);
    }
    return rt;
}
inline int change(int pre, int l, int r, int x)
{
    int rt = ++cnt;
    L[rt] = L[pre], R[rt] = R[pre], sum[rt] = sum[pre] + 1;
    if (l < r)
    {
        int mid = (l + r) >> 1;
        if (x <= mid)L[rt] = change(L[pre], l, mid, x);
        else R[rt] = change(R[pre], mid + 1, r, x);
    }
    return rt;
}
inline int search(int u, int v, int l, int r, int k)
{
    if (l >= r)return l;
    int x = sum[L[v]] - sum[L[u]];
    int mid = (l + r) >> 1;
    if (x >= k)return search(L[u], L[v], l, mid, k);
    else return search(R[u], R[v], mid + 1, r, k - x);
}
int main()
{
    scanf("%d%d", &n, &q);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        b[i] = a[i];
    }
    sort(b + 1, b + n + 1);
    m = unique(b + 1, b + n + 1) - b - 1;
    T[0] = build(1, m);
    for (int i = 1; i <= n; i++)
    {
        int t = lower_bound(b + 1, b + m + 1, a[i]) - b;
        T[i] = change(T[i - 1], 1, m, t);
    }
    while (q--)
    {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        int t = search(T[x - 1], T[y], 1, m, z);
        printf("%d\n", b[t]);
    }
    return 0;
}
```

### 组合数

```cpp
int qpow(int x, int y, int k)
{
	int res = 1;
	x %= k;
	while (y)
	{
		if (y & 1)
			res = res * x % k;
		x = x * x % k;
		y >>= 1;
	}
	return res;
}
void init()
{
	jc[0] = 1;
	for (int i = 1; i < N; i++)
		jc[i] = (jc[i - 1] * i) % mod;
	jc_inv[N - 1] = qpow(jc[N - 1], mod - 2, mod);
	for (int i = N - 1; i >= 1; i--)
		jc_inv[i - 1] = (jc_inv[i] * i) % mod;
}
int C(int x, int y)
{
	if (x < y || y < 0)
		return 0;
	if (y == 0)
		return 1;
	return	(jc[x] * jc_inv[y] % mod) * jc_inv[x - y] % mod;
}
```

